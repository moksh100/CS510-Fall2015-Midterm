"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\nclass Attractor(object):\n        \n        def __init__(self,  s=10, p=28, b=2.66667, start=0.0, end=80.0, points=10000):\n                self.params = np.array([s,p,b])\n                self.start = start \n                self.end = end\n                self.points = points\n                self.dt = (end-start)/points\n\n        def euler (self, ar = np.array([]), dt=0):\n                if(dt==0):\n                    dt =self.dt\n                x=ar[0]\n                y=ar[1]\n                z=ar[2]\n                dz = (x*y)-(self.params[2]*z)\n                dy = x*(self.params[1]-z)-y\n                dx = self.params[0]*(y-x)\n                xdt=x+(dx*dt)\n                ydt=y+(dy*dt)\n                zdt=z+(dz*dt)\n                return np.array([xdt,ydt,zdt])\n\n        def rk2 (self, ar = np.array([])):\n                dt=self.dt/2\n                k1= self.euler(ar)\n                x=ar[0]+k1[0]*dt\n                y=ar[1]+k1[1]*dt\n                z=ar[2]+k1[2]*dt\n                calc = self.euler(np.array([x,y,z]), dt)\n                return calc\n\n        def rk3 (self, ar = np.array([])):\n                dt=self.dt/2\n                k2= self.rk2(ar)\n                x=ar[0]+k2[0]*dt\n                y=ar[1]+k2[1]*dt\n                z=ar[2]+k2[2]*dt\n                calc = self.euler(np.array([x,y,z]), dt)\n                return calc\n\n        def rk4 (self, ar = np.array([])):\n                dt=self.dt\n                k3= self.rk3(ar)\n                x=ar[0]+k3[0]*dt\n                y=ar[1]+k3[1]*dt\n                z=ar[2]+k3[2]*dt\n                calc = self.euler(np.array([x,y,z]), dt)\n                return calc\n            \n            \n        def evolve(self, r0= np.array([0.1, 0.0, 0.0]), order =4):\n            iterator=np.arange(self.start+1, self.end, self.dt)\n            iterator=np.append(iterator, self.end)\n            result = np.array(np.append(0, r0))\n            v=r0;\n            if(order == 4):\n                for t in iterator:\n                    v = self.rk4(v)\n                    result = np.vstack((result,np.append(t, v)))\n            elif(order == 3):\n                for t in iterator:\n                    v = self.rk3(v)\n                    result = np.vstack((result,np.append(t, v)))\n            elif(order == 2):\n                for t in iterator:\n                    v = self.rk2(v)\n                    result = np.vstack((result,np.append(t, v)))\n            elif(order == 1):\n                for t in iterator:\n                    v = self.euler(v)\n                    result = np.vstack((result,np.append(t, v)))\n            \n            df = pd.DataFrame(result)\n            df.columns = ['t', 'x', 'y', 'z']\n            self.solution = df\n            return df        \n        \n        \n        def save(self):\n            self.solution.to_csv(\"export.csv\")\n            \n        def plotx(self):\n            self.solution['x'].plot()\n            plt.show()\n            \n        def ploty(self):\n            self.solution['y'].plot()\n            plt.show()\n                        \n        def plotz(self):\n            self.solution['z'].plot()\n            plt.show()\n            \n        def plotxy(self):\n            plt.plot(self.solution['t'],self.solution['x'],'g')\n            plt.plot(self.solution['t'],self.solution['y'],'r')\n            plt.show()\n        \n        def plotyz(self):\n            plt.plot(self.solution['t'],self.solution['y'],'g')\n            plt.plot(self.solution['t'],self.solution['z'],'r')\n            plt.show()\n        \n        def plotzx(self):\n            plt.plot(self.solution['t'],self.solution['z'],'g')\n            plt.plot(self.solution['t'],self.solution['x'],'r')\n            plt.show()\n           \n        def plot3d(self):\n            fig = plt.figure()\n            ax = fig.add_subplot(111, projection='3d')\n            ax.scatter(self.solution['x'], self.solution['y'], self.solution['z'])\n            plt.show()"